{
    "collab_server" : "",
    "contents" : "# 'Load 10X matrix files\n#'\n#' Loads the matrix files from a 10X run\n#'\n#' @return  get_cellranger_matrices returns a list of count matrices corresponding to the matrix files of \\code{filenames}. The names of the list are the basenames of \\code{filenames}\n\n#' @export\nget_cellranger_matrices <- function(filenames = character(), sample_name_prefix = NULL, genome_build = 'hg19')  {\n  matrix_list <- lapply(filenames, function(.filename)  {\n    temp_gbm <- cellrangerRkit::load_cellranger_matrix(.filename, genome = genome_build)\n    temp_gbm_mat <- as.matrix(temp_gbm@mat)\n    #gbm_gt1cell_mat <- gbm_mat[apply(as.matrix(gbm_mat), 1, function(.x)  {sum(.x > 1)}) > 1,]\n    # gbm_gt1cell_df <- as.data.frame(as.matrix(gbm_gt1cell_mat), optional = TRUE, stringsAsFactors = FALSE)\n    # gbm_gt1cell_df <- mutate(gbm_gt1cell_df, ENSEMBL = row.names(gbm_gt1cell_df))\n    # gbm_gt1cell_df <-  reshape2::melt(gbm_gt1cell_df, id.vars = 'ENSEMBL', variable.name = 'sample_name', value.name = 'count')\n    # gbm_gt1cell_df <- dplyr::rename(gbm_gt1cell_df, sample_name = variable, count = value)\n    # gbm_gt1cell_df <- left_join(gbm_gt1cell_df, gene_and_umi_counts_per_cell_df) %>% mutate(log_tpht = log2((count/umi_count)*1e5 + 1))\n\n    #get_matrix_from_df <- function(input_df, cast_formula = formula(\"sample_name ~ ENSEMBL\"), value.var = 'log_tpht')  {\n    #  temp_mat <- reshape2::acast(input_df, cast_formula, value.var = value.var)\n    #  return(temp_mat)\n    #}\n    return(temp_gbm_mat)\n  })\n  names(matrix_list) <- basename(filenames)\n  if(length(sample_name_prefix) > 0)  {\n    for(.ind in 1:length(sample_name_prefix))  {\n      colnames(matrix_list[[.ind]]) <- paste(sample_name_prefix[.ind], colnames(matrix_list[[.ind]]), sep = \"_\")\n      #return(matrix_list)\n    }\n  }\n  return(matrix_list)\n}\n\n# 'Load 10X matrix files\n#'\n#' Loads and merges the matrix files from a 10X run\n#'\n#' @return read_merge_and_return_sample_matrices returns a count matrices corresponding to the matrix files of \\code{filenames}. The matrices of the original samples are merged with the rows corresponding to samples and the columns corresponding to ensembl ids.\n\n#' @export\nread_merge_and_return_sample_matrices <- function(filenames = character(), sample_name_prefix = NULL, genome_build = 'hg19')  {\n  expr_mats <- get_cellranger_matrices(filenames, sample_name_prefix = sample_name_prefix, genome_build = genome_build)\n  shared_rownames <-  unique(unlist(lapply(expr_mats, rownames)))\n  raw_expr_mat <- t(do.call(cbind, lapply(expr_mats, function(.x)  {return(.x[shared_rownames,])})))\n  rm(expr_mats, filenames, shared_rownames)\n  return(raw_expr_mat)\n}\n\n#' Filter MT and Ribsomal protein genes\n#'\n#' Removes all mitochondrial and ribosomal protein genes in the count matrix and returns the reduces matrix.\n#'\n#' @return remove_ribosomal_proteins_and_mitochondrial_genes_from_matrix returns a reduced matrix with all mitochondrial and ribosomal protein genes removed\n\n#' @export\nremove_ribosomal_proteins_and_mitochondrial_genes_from_matrix <- function(cell_by_ensembl_mat = matrix(), species = 'hsapiens')  {\n  library(biomaRt)\n  if(!all(grepl(\"^ENS\", colnames(cell_by_ensembl_mat))))  {\n    stop(\"Column names should be ensembl ids and should start with 'ENS'\")\n  }\n  if(species == 'hsapiens')  {\n    ensembl <- biomaRt::useMart(\"ensembl\", dataset=\"hsapiens_gene_ensembl\")\n    useDataset(\"hsapiens_gene_ensembl\", mart=ensembl)\n    ensembl_gene_metadata_df <- biomaRt::select(ensembl, keys = colnames(cell_by_ensembl_mat), keytype = 'ensembl_gene_id', columns=c('ensembl_gene_id','chromosome_name', \"hgnc_symbol\", \"description\")) %>% dplyr::rename(ENSEMBL = ensembl_gene_id)\n    ensembl_gene_metadata_MT_and_ribosomal_df <- dplyr::filter(ensembl_gene_metadata_df, grepl(\"^RP[SL][01-9]\", ensembl_gene_metadata_df$hgnc_symbol) | (chromosome_name == 'MT'))\n  }\n  else {\n    warning(\"This is not a valid option\")\n    stop()\n  }\n  ensembl_overlaps <- colnames(cell_by_ensembl_mat)[which(colnames(cell_by_ensembl_mat) %in% ensembl_gene_metadata_MT_and_ribosomal_df$ensembl_gene_id)]\n  message(paste(length(ensembl_overlaps), 'of the', ncol(cell_by_ensembl_mat), 'ensembl ids are being removed'))\n  return(cell_by_ensembl_mat[,!colnames(cell_by_ensembl_mat) %in% ensembl_overlaps])\n}\n\n#' @export\nget_random_genes_from_matrix <- function(count_matrix = matrix(), distance_matrix = NULL, normalize_matrix = TRUE, range_of_counts = 2:50, n_sample_draws = 1000, tail_area = 0.2)  {\n  #remove zero counts\n  sample_names <- rownames(count_matrix)\n  lt2_names <- colnames(count_matrix)[apply(count_matrix, 2, function(.col)  {sum(.col) <= 1})]\n  gt1_mat <- count_matrix[,!colnames(count_matrix) %in% lt2_names]\n  if(normalize_matrix)  {\n    gt1_mat <- t(apply(gt1_mat, 1, function(.x) {log2(.x/sum(.x) * 1e6 + 1)}))\n  }\n  if(is.null(distance_matrix))  {\n    cor_mat <- cor(t(gt1_mat))\n    dist_mat <- 1 - cor_mat\n  }\n  else {\n    dist_mat <- distance_matrix\n  }\n\n  cell_non_zero_gene_counts <- apply(gt1_mat, 2, function(.x)  {sum(.x >0)})\n  valid_cell_non_zero_gene_counts <- cell_non_zero_gene_counts[(cell_non_zero_gene_counts %in% range_of_counts)]\n\n  tested_genes_pval_and_dif_mat_list <- lapply(unique(valid_cell_non_zero_gene_counts), function(.count)  {\n\n    mean_pw_cor <- sapply(1:n_sample_draws, function(.ind)  {\n      sub_sample_names <- sample(sample_names, .count, replace = FALSE)\n      sampled_names_mat <- dist_mat[sub_sample_names,sub_sample_names]\n      get_mean_dist_from_matrix(sampled_names_mat)\n    })\n    mean_mean_pw_cor <- mean(mean_pw_cor)\n    #print(mean_pw_cor)\n    sd_mean_pw_cor <- sd(mean_pw_cor)\n\n    genes_pval_and_dif_mat <- sapply(names(valid_cell_non_zero_gene_counts[valid_cell_non_zero_gene_counts == .count]), function(.gene_name)  {\n      selected_sample_names <- rownames(gt1_mat)[which(gt1_mat[,.gene_name] > 0)]\n      selected_mean_val<- get_mean_dist_from_matrix(dist_mat[selected_sample_names,selected_sample_names])\n      return(c(mean(mean_pw_cor < selected_mean_val), log10(selected_mean_val/min(mean_pw_cor))))\n    })\n    #print(head(genes_pval_and_dif_mat))\n    return(genes_pval_and_dif_mat)\n  })\n  return(t(do.call(cbind, tested_genes_pval_and_dif_mat_list)))\n  #return(unique(c(unlist(names(genes_to_remove_list)), lt2_names)))\n}\n\n#` Calculate mean value from matrix\n#'\n#' The function calculates and returns the mean of the upper-triangular portion of a matrix\n#'\n#' @return get_mean_dist_from_matrix returns the upper-triangular mean of temp_mat, exluding the zeros from the diagonal or the lower-triangular portion of the matrix\n#'\nget_mean_dist_from_matrix <- function(temp_mat)  {\n  temp_mat[!upper.tri(temp_mat)] <- 0\n  #print(temp_mat)\n  mean(temp_mat[temp_mat != 0])\n}\n\n#converts a named charcter vector into a 2-column data.frame with the column names specified by col_names\n#' @export\nget_df_from_named_char_vector <- function(char_vec = character(), col_names = character())  {\n  temp_df <- as.data.frame(char_vec)\n  names(temp_df) <- col_names[2]\n  temp_df[col_names[1]] <- row.names(temp_df)\n  temp_df <- temp_df[,2:1]\n  row.names(temp_df) <- NULL\n  return(temp_df)\n}\n\n#subsample the count matrix such that each cell (row) has threshold_level reads. Currently, cells with fewer reads are discarded, although in the future they will be upsampled based on similar cell read/UMI counts\n#' @export\nrarefy_count_matrix <- function(count_matrix = matrix(), threshold_level = numeric())  {\n  counts_per_cell <- apply(count_matrix, 1, sum)\n  count_sub_mat <- count_matrix[counts_per_cell >= threshold_level,]\n  gene_by_sample_mat <- sapply(rownames(count_sub_mat), function(.sample_name)  {\n    sample_prob <-  threshold_level / counts_per_cell[.sample_name]\n    return(sapply(count_sub_mat[.sample_name,], function(.col)  {\n      return(rbinom(rep(1, length(.col)), .col, sample_prob))\n    }))\n  })\n  return(t(gene_by_sample_mat))\n}\n\n#This function takes a data.frame with numeric columns, computes the aic for clusterings with 1:25 clusters, identifies the cluster number such that the following clustering number has a higher AIC, and returns the cluster identity vector of each row of the input data.frame using that optimal cluster number.\n#' @export\nget_best_aic_cluster_assignment <- function(clustering_df = data.frame())  {\n  aic_scores <- sapply(1:25, function(.x)  {\n    mclust_obj <- Mclust(clustering_df, G =.x)\n    return(2*mclust_obj$df - 2*mclust_obj$loglik)\n  })\n  n_clusters <- which(aic_scores[-length(aic_scores)] < aic_scores[-1])[1]\n  n_clusters <- ifelse(length(n_clusters) > 0, n_clusters, length(aic_scores))\n  return(Mclust(clustering_df, G = n_clusters)$classification)\n}\n\n\n#' Compute distance between samples\n#'\n#' Use cidr to compute inter-sample distances and return named distance matrix\n#'\n#' @return get_cidr_distance_matrix_from_raw_counts returns a named distance matrix showing the distance between samples. Both rows and columns are named.\n#'\n#' @export\nget_cidr_distance_matrix_from_raw_counts <- function(cell_by_ensembl_mat = matrix()) {\n  cidr_obj <- cidr::scDataConstructor(apply(cell_by_ensembl_mat, 1, function(.x)  {\n    log2((.x/sum(.x)) * 1e5 + 1)\n  }))\n  cidr_obj <- cidr::determineDropoutCandidates(cidr_obj)\n  cidr_obj <- cidr::wThreshold(cidr_obj)\n  cidr_obj <- cidr::scDissim(cidr_obj)\n  dist_mat <- cidr_obj@dissim\n  dimnames(dist_mat) <- list(rownames(cell_by_ensembl_mat), rownames(cell_by_ensembl_mat))\n  return(dist_mat)\n}\n",
    "created" : 1472141937904.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "7|113|32|0|\n41|127|47|0|\n133|93|140|0|\n144|88|154|0|\n158|76|166|0|\n176|86|186|0|\n",
    "hash" : "3372387132",
    "id" : "48F1D6CE",
    "lastKnownWriteTime" : 1475081114,
    "last_content_update" : 1475081114514,
    "path" : "~/Dropbox/r_package_dev/rnaseqUtils/R/utility_functions.R",
    "project_path" : "R/utility_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}